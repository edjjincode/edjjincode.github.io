---
layout: single
title: "[네이버부스트AI준비]/Python Object-Oriented Programming"
categories: TIL
tag: [네이버프리코스]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

# 파이썬 객체지향(OOP)

객체: 실생활에서 일종의 물건(속성와 행동을 가짐)

속성은 변수, 행동은 함수로 표현됨

OOP는 설계도에 해당하는 **클래스**와 **실제 구현체인 인스턴스**로 나뉨

## Object in Python

```python
class SoccerPlayer(object):
    def __init__(self, name, position, back_number):
        self.name = name
        self.position = position
        self.back_number = back_number

    def change_back_number(self, new_number):
        print("선수의 등번호를 변경합니다. From %d to %d" % (self.back_number, new_number))
        self.back_number = new_number
```

- Attribute 추가는 **init**, self와 함께!

**init**은 객체 초기화 예약 함수

- \_\_는 특수한 예약 함수나 변수 그리고 함수명 변경으로 사용

예: **main**, **add**, **str**, **eq**

**[self가 의미하는 것은?]**

생성된 인스턴스 자신을 가리키는 것이다.

## 실제 사용할 때 필요한 것들

1. Inheritance(상속)
2. Polymorphism(다형성)
3. Visibility

### 상속

- 부모 클래스로 부터 속성과 Method를 물려받은 자식 클래스를 생성하는 것

```python
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Korean(Person):
    pass#Korean에는 아무 속성이 안들어 있지만 Person을 상속 받았기 때문에 사용할 수 있다.

first_korean = Korean("Sungchul", 35)
print(first_korean)
```

<부모 클래스 상속 예시>

```python

class Employee(Person):
    def __init__(self, name, gender, salary, hire_date):
        super().__init__(name, age, gender)# 부모객체 사용
        self.salary = salary
        self.hire_date = hire_date # 부모객체에 없었던 속성 추가

    def do_work(self): #새로운 메서드 추가
        print("열심히 일을 합니다.")

    def about_me(self): #부모 클래스 함수 재정의
        super().about_me() # 부모 클래스 함수 사용
        print("제 급여는 ", self.salary, "원 이구요, 제 입사일은", self.hire_date, "입니다.")
```

### 다형성

- 같은 이름 메소드의 내부 로직을 다르게 작성

- Dynamic Typing 특성으로 인해 파이썬에는 같은 부모 클래스의 상속에서 주로 발생함

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def talk(self):
        raise NotImplementedError("Subclass must implement abstract method")

class Cat(Animal):
    def talk(self):
        return "Meow!"

class Dog(Animal):
    def talk(self):
        return "Woof! Woof!"

animals = [Cat("Missy"), Cat("Mr.Mistoffelees"),Dog("Lassie")]

for animal in animals:
    print(animal.name + ":" + animal.talk())

```

위 코드와 같이 동일한 talk 메소드를 다른 출력 값을 갖도록 했다.

### Visibility:

- 객체의 정보를 볼 수 있는 레벨을 조절하는 것
- 누구나 객체 안에 모든 변수를 볼 필요가 없음

1. 객체를 사용하는 사용자가 임의로 정보 수정
2. 필요 없는 정보에는 접근 할 필요가 없음
3. 만약 제품으로 판매한다면? 소스의 보호

- 캡슐화 또는 정보 은닉
- Class를 설계할 때, 클래스 간 간섭/정보 공유의 최소화
- 심판 클래스가 축구선수 클래스 가족 정보를 알아야 하나?

<A>

```python

class Product(object):
    pass
class Inventory(object):
    def __init__(self):
        self.items = [] #Private 변수로 선언 타객체가 접근 못함

    def add_new_item(self, product):
        if type(product) == Product:
            self.items.append(product)
            print("new item added")
        else:
            raise ValueError("Invalid Item")

    def get_number_of_items(self):
        return len(self.items)

```

<B>

```python

class Product(object):
    pass
class Inventory(object):
    def __init__(self):
        self.__items = [] #Private 변수로 선언 타객체가 접근 못함

    def add_new_item(self, product):
        if type(product) == Product:
            self.__items.append(product)
            print("new item added")
        else:
            raise ValueError("Invalid Item")

    def get_number_of_items(self):
        return len(self.__items)

```

<A> 예시와 <B> 예시의 가장 큰 차이점은 A같은 경우 접근 제한자가 없으나 B는 접근 제한자가 있다는 점이다.

A 예시를 통해 인스턴스를 생성한 후 items를 읽어 오는 것은 가능하나 B예시에서 인스턴스를 생성한 후 \_\_items를 읽어오는 것은 안된다.

상황에 따라 접근을 제한하였는 데 필요에 따라서 접근을 하고 싶을 때가 있을 수도 있다. 이때 사용하는 것이 decorate이다.

```python

class Inventory(object):
    def __init__(self):
        self.__items = []

    @property#숨겨진 변수를 반환하게 해줌
    def items(self):
        return self.__items

my_inventory = Inventory()
my_inventory.add_new_item(Product())
my_inventory.add_new_item(Product())
print(my_inventory.get_number_of_items())

items = my_inventory.items #Property decorator로 함수를 변수처럼 호출
items.append(Product())
print(my_inventory.get_number_of_items())
```

### Decorate

**[First-class objects]**

- 일등함수 또는 일급 객체
- 변수나 데이터 구조에 할당이 가능한 객체
- 파라미터로 전달이 가능 + 리턴 값으로 사용

파이썬의 함수는 일급함수이다. 예: map 함수

```python

def formula(method, argument_list):
    return [method(value) for value in argument_list] #함수를 파라미터로 사용
```

- **closures: inner function을 return 값으로 반환**

```python

def print_msg(msg):
    def printer():
        print(msg)
    return printer

another = print_msg("Hello, Python")
another

```

print_msg라는 함수 안에 있는 inner function printer를 return 값으로 사용할 수 있다.

<비슷한 예시>

```python

def tag_func(tag, text):
    text = text
    tag = tag

    def inner_func():
        return '<{0}>{1}<{0}>'.format(tag, text)

    return inner_func

h1_func = tag_func('title', 'This is Python Class')
p_func = tag_func('p','Data Academy')

```

**decorate는 복잡한 클로져 함수를 간단하게 만들어 준다.**

```python

def star(func):
    def inner(*args, **kwargs):
        print("*" * 30)
        func(*args, **kwargs)
        print("*", 30)
    return inner

@star
def printer(msg):#Star함수의 func으로 printer가 들어가게 된다.
    print(msg)
printer("Hello")

```
