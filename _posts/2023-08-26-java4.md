---
layout: single
title: "[우테코 준비#4]/자바 강의#4"
categories: 자바 기초
tag: [Java 자바기초]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

# 상속:

OO는 OO다. OO는 OO의 종류 중 하나다. 라고 표현할 수 있다면 이것은 상속관계라고 말할 수 있다. 상속 관계는 is a 관계 혹은 kind of 관계라고도 한다.

자식 클래스들을 부모 클래스로 부를 수 있는 것을 **일반화**라고 한다.

상속은 일반화 + 확장의 개념으로 생각하면 된다.

상속은 굉장히 강한 결합이다. 상속은 반드시 써야만 할 때만 쓰고 되도록 사용 안하는게 좋다.

## 상속 선언 방법:

**[접근제한자][abstract | final] class 클래스명 extends 부모클래스명{}**

모든 클래스는 Object의 자손이다.

부모 타입으로 자손 타입을 참조할 수 있다.

```java
Car car = new Bus();
```

부모 타입(Car)으로 자손 타입(Bus)을 참조한다면 부모 타입이 할 수 있는 메소드만 실행할 수 있게 된다.

## 다형성- 메소드 오버라이딩(Overriding)

- over + ride = 올라 타다
- 상위 클래스의 메서드를 하위 클래스가 재정의 하는 것이다.
- 메서드의 이름은 물론 파라미터 갯수나 타입도 동일해야 하며, 주로 상위 클래스의 동작을 상속 받은 하위 클래스에서 변경하기 위해 사용된다.

### **메소드가 오버라이딩 되면 무조건 자식 메소드가 실행된다.**

```java
Car car = new Bus();
car.run();
```

- Car을 참조하였으나 Bus가 오버라이딩 되었으므로 car.run()을 하면 Bus의 run()메소드가 실행된다.

**필드는 Type을 따라가게 된다. 오버라이딩 되었다고 무조건 자식을 따라가지 않는다**

### **메소드 오버라이딩만 기억한다**

필드는 직접 접근을 하지 않고 메소드를 통해 접근하도록 해야 한다.(필드는 외부에서 접근 못하도록 해야 한다) 이를 흔히 **정보 은닉**이라고 한다.

## Getter & Setter 프로퍼티:

```java
public class Book{
  public int price;
}
```

라는 Book 클래스를 만들고

```java
public class BookExam01{
  public static void main(String[] args){
    Book b1 = new Book();
    b1.price = 100;//b1 인스턴스의 필드의 접근한다.
    System.out.println(b1.price)
  }
}

```

Book 클래스의 필드 값을 출력하는 클래스를 만들어 보았다. 이때 앞서 언급한 것과 같이, 인스턴스의 필드 값을 직접 불러오는 것은 좋은 코딩이라 보기 어렵기 때문에 getter와 setter를 통해 필드 값을 불러오는 것이 좋다.

만약 Book 클래스의 price 필드를 private 하게 바꾸면, BookExam01에서 price 필드를 불러올 수 없게 된다.

```java
public class Book{
  private int price;
}
```

```java
public class BookExam01{
  public static void main(String[] args){
    Book b1 = new Book();
    b1.price = 100;//b1 인스턴스의 필드의 접근한다.
    System.out.println(b1.price)
  }
}

// 컴파일 오류가 뜬다.
```

getter와 setter를 사용하기 위해 Book 클래스를 수정한다.

```java
public class Book{
  private int price;

  //필드의 값을 수정하고 얻기 위한 메소드를 만든다. setter, getter

  public int getPrice(){
    return this.price; //this는 내 자신 인스턴스를 참조하는 예약어이다.
  }

  public void setPrice(int price){ //메소드 안에 지역변수로 들어가는 price이다.
    this.price = price; //외부로 받은 price로 필드 값을 할당한다
  }
}
```

이렇게 Book 클래스를 변형시킨 후 이를 실해시키 위해 BookExam01을 수정한다.

```java

public class BookExam01{
  public static void main(String[] args){
    Book b1 = new Book();

    b1.setPrice(500);
    System.out.println(b1.getPrice());
  }
}

//출력값: 500

```

setter와 getter를 사용하게 될 시, 이점은 필드 값을 변형하기 쉽다는 점이다.

```java
public class Book{
  private int price;

  //필드의 값을 수정하고 얻기 위한 메소드를 만든다. setter, getter

  public int getPrice(){
    return this.price * 2;
  }

  public void setPrice(int price){
    this.price = price;
  }
}
```

위와 같이 getPrice의 값을 바꾸면, 출력 값이 손쉽게 바뀌게 된다.

이러한 setter, getter를 price 프로퍼티라고 한다.

## Object의 오버라이딩 하라고 제공하는 toString(), equals(), hashCode() 메소드

```java
public class Car{
  public static void Main(String[] args){
    System.out.println("전륜구동으로 달리다");
    }
}
```

이를 실행하는 코드를 짜면 다음과 같이 짤 수 있다.

```java

public class CarExam{
  public static void Main(String[] args){
    Car c1 = new Car();
    System.out.println(c1);
  }
}
```

이렇게 하면 출력 값이 Car@6b71769e로 나온다.

해당 값이 오류가 안난다는 것은 사용된 println()이 println(Object)라는 것이다.

앞서 부모타입의 변수로 자식인스턴스를 참조할 수 있다고 배운 바 있다.

```java
Car c1 = new Bus();
Car c2 = new 이층버스(); //이층 버스는 Car의 자손이다.
```

해당 코드가 오류가 안난다는 것은 Bus가 Car를 상속받기 때문이다.

아무것도 상속을 받고 있지 않을 때는 Object를 상속 받고 있는 것이다.

```java
Object o1 = new Car(); //이런 식으로 코딩을 할 수 있다.
```

다시 println으로 돌아오면, 위 코드에서 사용된 println 코드는 println(Object)이고 이는 실제론 System.out.println(c1.toString()); 와도 같은 것이다.

하지만 해당 출력값은 아무 쓸모가 없기 때문에 toString을 override해서 출력하고자 하는 값을 출력할 수 있다.

```java

public class Car{
  public static void Main(String[] args){
    System.out.println("전륜구동으로 달리다");
    }

  @override
  public String toString(){
    return "자동차!!"
  }
}

```

위와 같은 코드로 Car 클래스를 수정 후 다시 실행하면 출력 값이 "자동차!!"가 나오게 된다.
