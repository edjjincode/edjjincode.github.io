---
layout: single
title: "[우테코 준비#6]/자바 강의#6"
categories: 자바 기초 TIL
tag: [Java 자바기초]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

# 추상 클래스

- 추상 클래스는 인스턴스가 될 수 없다.
- 추상 클래스를 상속받는 자손이 인스턴스가 된다
- abstract 키워드를 사용하여 클래스를 정의한다.
- 추상 클래스는 보통 1개 이상의 추상 메소드를 가진다
- public abstract class

추상 클래스 Car2를 만든다.

```java
public abstract class Car2{
    public Car2(String name){
        System.out.println("Car2() 생성자 호출");
    }
}
```

이를 실행하기 위해 코드를 짜보면,

```java
public class Car2Exam{
    public static void main(String[] args){
        Car2 c = new Car2("urstory");
    }
}
```

하면 오류가 뜬다. 이는 추상 메소드 Car2는 인스턴스를 생성할 수 없기 때문이다.

자 이번에는 Car2를 상속받는 Bus2를 생성해 보겠다.

```java
public class Bus2 extends Car2{
    public Bus2(){
        super("Bus!!");
        System.out.println("Bus2기본생성자");
    }
}
```

```java
public abstract class Car2Exam{
    public static void main(String[] args){
        Bus2 b = new Bus2("bus!");
    }
}
```

Car2를 상속 받은 Bus2의 인스턴스를 생성하게 되면 오류가 없이 결과 값이 나올 수 있다는 것을 알 수 있다.

이때 Car2 클래스를 만든 사람은 run()이라는 메소드가 필요하다고 생각을 하고 이 run()이라는 메소드를 자동차마다 다르게 구현하고자 한다

이럴 때 Car2클래스에 추상 메소드 run()을 만들어서 구현할 수 있다.

```java
public abstract class Car2{
    public Car2(String name){
        System.out.println("Car2() 생성자 호출");
    }

    public abstract void run();

}
```

이후 Car2에서 상속 받은 Bus2를 실행한다.

```java
public class Bus2 extends Car2{
    public Bus2(){
        super("Bus!!");
        System.out.println("Bus2기본생성자");
    }

    //부모가 가지고 있는 추상메소드는 자식에서 반드시 구현을 해줘야 한다.
    @override
    public void run(){
        System.out.println("후륜구동으로 동작한다");
    }
}
```

이때 부모가 가지고 있는 추상 메소드는 자식에서 반드시 구현을 해줘야 하므로 Bus2에서 run 메소드를 작성해준다.

## 템플릿 메소드 패턴으로 배우는 추상 클래스

com.example에 fw라는 패키지를 만들고 controller 클래스를 만들었다.

```java
package com.example.fw
//Controller의 종류가 여러개더라
//초기화- 같은 코드
//실행- 다른 코드?
//마무리= 같은 코드
public abstract class Controller{
    public void init(){
        System.out.println("초기화 하는 코드");
    }
    public void close(){
        System.out.println("마무리하는 코드 ");
    }

    public abstract void run();

    //내가 가지고 있는 메소드를 호출한다
    //어떤 순서를 가지고 있다. 이런 메소드를 템플릿 메소드라고 한ㄷ.
    public void execute(){
        this.init();
        this.run();
        this.close();
    }
}
```

com.example에 myproject라는 폴더를 만든 후 FirstController 클래스를 만들고 이를 Controller에 상속 받았다.

```java
package com.example.myproject;

import com.example.fw.Controller;

public class FirstController extends Controller{
    // 추상 클래스를 상속 받았으므로 무조건 override를 해줘야 한다.
    @Override
    public void run(){
        System.out.println("별도로 동작하는 코드 1111");
    }
}

```

FirstController 클래스는 추상 클래스 Controller를 상속 받았으므로 override를 해줘야 한다.

```java
package com.example.main;

import com.example.fw.Controller;
import com.example.myproject.FirstController;

public class ControllerMain {
    public static void main(String[] args){
        Controller c1 = new FirstController();
        c1.execute();
    }
}
```

FirstController 클래스를 실행시키기 위해 ControllerMain 클래스를 만든 후 부모 클래스의 c1 인스턴스를 생성하고 c1에 execute 메소드를 실행하였다. 이때 Controller 클래스에 있는 run 메소드를 override 하였으므로 FirstController에 override한 run 메소드가 출력된다.

이렇게 실행하고 나니, c1.init() 혹은 c1.close()도 메소드 접속이 가능하다는 것을 알게 되었다. 이는 Controller 클래스의 접근 제한자가 public이기 떄문이다.

만일 같은 패키기이거나 상속 받을 때만 메소드를 호출하도록 하려면 클래스 메소드의 접근제한자를 protected로 바꿔줘야 한다.

```java
public abstract class Controller{

    //protected는 같은 package이거나 상속 받았을 떄 접근 가능하다.
    protected void init(){
        System.out.println("초기화 하는 코드");
    }
    protected void close(){
        System.out.println("마무리하는 코드 ");
    }

    protected abstract void run();

    //내가 가지고 있는 메소드를 호출한다
    //어떤 순서를 가지고 있다. 이런 메소드를 템플릿 메소드라고 한ㄷ.
    public void execute(){
        this.init();
        this.run();
        this.close();
    }
}
```
