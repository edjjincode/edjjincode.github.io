---
layout: single
title: "[우테코 준비#2]/자바 강의#2"
categories: 자바 기초, TIL
tag: [Java, 자바기초, TIL]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

# 우테코 준비 #2:

객체지향 프로그래밍(OOP)은 컴퓨터 프로그래밍의 패러다임 중 하나이다.

클레스(Class), 오브젝트(object), 인스턴스(instance), 참조형 변수(Reference Variable) 단어들에 대해 알고 있어야 한다.

**설계도면**은 **클래스**와 유사하다.

설계도면을 보고 실제 책상을 만들게 된다. 이때 **책상**을 **오브젝트** 혹은 **인스턴스**라고 부른다.

❗우리가 클래스 지향 프로그래밍이라고 말하지 않고 객체 지향 프로그래밍이라고 말하는 이유는 무엇일까?

클래스는 실제 존재하는 물체 즉 오브젝트가 아니라 동작하지 않는다. 실제로 만들어진 현실에 있는 객체를 이용하는 것이다.

현실에 존재할 인스턴스가 어떻게 동작할까? 라는 것을 고민하고 그걸 프로그래밍 하는 것이 객체 지향 프로그래밍이다.

인스턴스를 **특별한 이름으로 부르고 싶다**면 **참조형 변수**를 사용하면 된다.

❗앞으로 new 클래스 이름()와 유사한 문장을 보면, 클래스 이름에 해당하는 인스턴스를 생성한다고 이해하면 된다. 클래스 이름(): 생성자라고 한다.

```java

Book b = new Book();

```

이라는 코드에서 Book()에 해당하는 부분을 생성자라고 하고, b를 참조형 변수라고 한다.

참조한다는 것은 가리킨다는 것을 의미한다.

여기서 Book을 레퍼런스 타입이라고 한다.

new Book()이라는 코드를 치게 되면 컴퓨터에서는 Book 인스턴스가 Heap 메모리에 생성된다. 그리고 이 인스턴스를 참조형 변수 b가 가리키게 된다.

## 클래스:

클래스는 필드와 메소드를 가진다. 필드는 클래스의 속성이라고 말할 수 있다. 메소드는 클래스의 기능이라고 말할 수 있다.

클래스 앞에는 접근 제한자가 붙는다.

접근 제한자에는 public, protected, private, default가 올 수 있다.

클래스 다음에는 클래스 이름이 나온다.

- 클래스 이름은 대문자로 시작한다.

✔ static이 붙은 메소드는 클래스 메소드라고 부른다.

✔ 클래스 메소드는 인스턴스를 생성하지 않아도 사용할 수 있다.(클래스 메소드는 인스턴스를 생성하지 않아도 메모리에 올라가 있다는 뜻이다.)

❗메소드 안에서 사용되는 것은 다 의존하는 것이다.

# 인스턴스를 만드는 3가지 방법

1. new 연산자와 생성자를 이용하여 인스턴스를 만드는 방법
2. 클래스 로더를 이용하는 방법
3. 메모리에 있는 인스턴스를 복제하여 만드는 방법

❗인스턴스를 만들 떄마다 메모리에 인스턴스가 생성되기 때문에 필요한 개수만큼 잘 만들어야 한다.

❗어떤 객체가 어떤 객체에게 메소드를 호출하는 것이 메시징이다.

메소드가 언제 호출되고 어떻게 호출될까? 메소드의 이름은 어떻게 지어야 할까? 어떻게 호출해야 할까를 고민해야 한다.

요청을 처리하기 위해 객체가 수행하는 행동을 책임이라고 한다.

## 메소드

### 메소드 선언 방법

[접근제한자][static] 리턴 type 메소드이름([매개변수, ....]){

}-메소드 블록

```java
public static void main(String[] args){

}
```

메소드 이름은 소문자로 시작한다.

void는 return하는 값의 타입이다. return하는 값이 void이면, return 하는 값이 없다는 것이다. 만약, 메소드가 return하는 값이 int이면, return 하는 값이 int라는 뜻이다.

### static 메소드

**[VendingMachine 예시] static이 있을 때와 없을 때의 차이**

```java

public class VendingMachine{

    public String pushProductButton(int menuId){
        System.out.println(menuId + "를 생성하였습니다.");
        return "콜라";
    }

    public static void printVerison(){
        System.out.println("1.0v");
    }

}
```

static이 있는 메소드는 굳이 instance를 만들 필요 없이 사용할 수 있다. 하지만 static이 아닌 메소드는 인스턴스를 안 만들면 사용할 수 없다.

```java
public class VendingMachineMain{

    public static void main(String[] args){
        VendingMachine.printVersion()//printVersion은 static이기 때문에 바로 실행되나,
        VendingMachine.pushProductMachine()//pushProductMachine 같은 경우, 인스턴스를 만들지 않았기 때문에 실행되지 않는다.
    }
}
```

**[Math 클래스 예시]**

![MathClass]({{site.url}}/images/2023-08-21-java2/mathclass.png)

Java API에서는 Math 클래스를 제공한다.

이때 JAVA API란 자바 개발자가 제공하는 명령어를 말한다. API 문서란 명령어들의 사용법과 규격을 제공하는 문서를 말한다.

위에 있는 Math 클래스 같은 경우, extends 부분에 Object가 있다. 이는 Math라는 클래스가 Object를 상속 받는다는 뜻이다.

![MathMethod]({{site.url}}/images/2023-08-21-java2/mathmethod.png)

Math method 같은 경우, 메소드들이 대부분 static이라는 것을 알 수 있다. 따라서 따로 인스턴스를 만들지 않고 바로 사용할 수 있다.

![MathTest]({{site.url}}/images/2023-08-21-java2/mathtest1.png)

Math 클래스에 인스턴스를 생성하지 않고 실행하니 오류 없이 돌아가는 것을 확인할 수 있었다.

![MathTest2]({{site.url}}/images/2023-08-21-java2/mathtest2.png)

하지만 Math 클래스에 인스턴스를 생성하고 실행하면 private 오류가 뜨는 것을 확인할 수 있다.

왜 private 오류가 뜰까?

이를 이해하기 위해 Math 클래스의 abs와 동일한 기능을 하는 MyMath 클래스를 만들어 보았다.

![mymath]({{site.url}}/images/2023-08-21-java2/mymath.png)

Java API에서 제공하는 것과 같이 abs 메소드를 static으로 지정해 주었다. 이 상태에서 mymath 클래스를 실행할 수 있는 MyMathTest 클래스를 만든 후 인스턴스를 생성하고 돌려보았다.

![mymathtest]({{site.url}}/images/2023-08-21-java2/mymathtest.png)

Math 클래스에서는 private 오류가 뜬 것과 달리 MyMathTest에서는 private 오류가 뜨지 않는 것을 확인할 수 있다. 이는 MyMathTest와 같이 일반적으로 클래스에서 생성자를 하나도 만들지 않으면 컴파일 시점에서 자동으로 접근 제한자가 public인 생성자가 만들어지기 때문이다.

반면 Math 클래스의 생성자는 private이기 때문에 인스턴스를 생성한 후 실행을 하게 되면 오류가 뜨게 된다.

### 메소드가 실행될 때 어떤 일이 벌어지는 가?

메소드 안에 선언된 지역 변수는 메소드가 실행될 때 생성되었다가 메소드가 종료될 때 사라진다. 동시에 메소드가 호츨되도 문제가 없다.

### 클래스 메소드(static method) VS 인스턴스 메소드

- 인스턴스 별로 다르게 동작해야 한다면 인스턴스 메소드
- static메소드는 객체 생성이나 유틸리티 관련에서 사용될 때가 있다.

* 되도록 인스턴스 메소드를 사용한다.

## 필드(field)

- 클래스가 가지는 속성을 자바 언어에서는 필드라고 한다
- 다른 언어에서는 멤버 변수라고도 한다
- 필드는 어떤 키워드와 함께 사용하느냐에 따라서 사용방법이 달라진다

* static이라는 키워드와 함꼐 사용되는 필드는 클래스 필드, 함께 사용되지 않는 필드를 인스턴스 필드라고 한다.

**[필드 선언 방법]**

**[접근제한자][static][final]타입필드명[=초기값]**

### static field

static 필드는 인스턴스를 따로 만들지 않아도 메모리가 올라가게 된다.

static 필드는 클래스.필드 형태로 사용하는 것이 가장 좋다.

![staticfield]({{site.url}}/images/2023-08-21-java2/staticfield.png)

Person 클래스에 count라는 static 필드를 만들었다.이를 출력하기 위해 Person Test라는 클래스를 만들었다.

동일한 생성자 Person을 통해 p1,p2 각각 인스턴스를 만든 후, p1의 count를 늘린 후 p1,p2의 count 값을 비교하였다.

![staticfield2]({{site.url}}/images/2023-08-21-java2/staticfield2.png)

위와 같이 p1의 카운트를 늘렸는 데 p2의 카운트도 오른 것을 확인할 수 있다. 이는 static 필드를 사용할 시 메모리가 인스턴스를 생성하지 않아도 올라가기 때문이다.

**static한 메소드에서 인스턴스 필드를 불러 올 수 있을 까?**

static한 메소드에서는 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 그 이유는 인스턴스 메소드와 static 메소드의 메모리가 생성되는 시점이 다르기 때문이다.

```java
public class Hello2{
    public static void main(String[] args){
        System.out.println("Hello")
    }
}

```

위와 같은 코드를 실행하게 되면, Hello2.java 소스를 컴파일하고(javac Hello2.java) java를 실행하면(java Hello2) JVM은 CLASSPATH에서 Hello2 클래스를 찾게 된다. 이후 이 클래스를 읽어 들여서 그 정보를 메모리에 올리게 된다.

클래스 정보를 메모리에 올릴 때, static한 필드나 static한 메서드가 있을 때 사용 가능하게 메모리에 올린다.

static 필드는 바로 초기화 할 수도 있고, static 블록을 통해서 초기화 할 수 있다.

```java
public class Hello2{

    static int i;
    static{
        i = 500;
        System.out.println("static block");
    }

    public static void main(String[] args){
        System.out.println("Hello")
    }
}

```

static 필드를 최기화 한 후에는 메인 메소드를 찾고 실행하게 된다. 이때 main 메소드가 static이므로 별도로 인스턴스를 생성하지 않아도 실행 가능하다.

위 코드를 실행하면,

```java
static block
Hello
```

라고 출력된다. 이는 static 블록이 메소드보다 먼저 실행되기 때문이다.

## 메모리

- new 연산자를 사용할 때마다 메모리에 인스턴스가 생성된다
- 인스턴스는 더 이상 참조되는 것이 없을 때, 나중에 가비지 컬렉션이 된다.
- static한 필드는 클래스가 로딩될 때 딱 한번 메모리에 올라가고 초기화 된다.
- 인스턴스 메소드는 인스턴스를 생성하고나서 레퍼런스 변수를 이용해 사용할 수 있다.
- 클래스 메소드는 클래스명.메소드명() 으로 사용 가능하다.
- 메소드 안에 선언된 변수들은 메소드가 실행될 때 메모리에 생성되었다가, 메소드가 종료될 때 사라진다.

## 추상화

- 중요한 것은 남기고, 불필요한 것은 제거한다.

- 도메인에 맞는 추상화를 해야 한다.

## 캡슐화

- 관련된 것을 잘 모아서 가지고 있는 것을 캡슐화라고 말한다. 관련된 것을 잘 모아서 가지고 있을수록 응집도가 높다고 표현한다.

**[좋은 객체는 응집도는 높고 결함도는 낮다]**

응집도가 좋다는 것은 **주요 기능이 잘 작동해야 한다는 것이다**.

세탁기는 세탁하는 데 필요한 주요 기능들이 잘 가지고 있으면 응집도가 높다라고 할 수 있다.

결함도가 낮다는 것은 부가적인 기능이 있어야 무엇인가 작동하는 정도가 낮다는 것이다.

## 다형성:

**다형성-메소드 오버로딩**

- 메서드의 이름은 같고 매개변수의 갯수나 타입이 다른 함수를 정의하는 것을 의미한다.
- 리턴 값만을 다르게 갖는 오버로딩은 작성 할 수 없다.

메소드 오버로딩을 왜 하게 되는 걸까?

정수를 출력하는 메소드 이름은 println(), 문자열을 출력하는 메소드 이름은 printString()처럼 어떤 타입을 출력하느냐에 따라서 메소드 이름이 달라진다면 사용자가 외워야 할 메소드 수가 늘어서 힘들 것이다.
