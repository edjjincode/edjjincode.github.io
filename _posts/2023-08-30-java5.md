---
layout: single
title: "[우테코 준비#5]/자바 강의#5"
categories: 자바 기초 TIL
tag: [Java 자바기초]
toc: true
author_profile: false
sidebar:
  nav: "docs"
---

# 생성자:

**[생성자]**

- 인스턴스를 생성할 때 사용한다
- 어떤 값을 가지고 인스턴스가 만들어지게 하고 싶다면 생성자를 사용한다
- 클래스 작성시 생성자를 하나도 만들지 않았다면 자동으로 **기본 생성자**가 생성된다
- 기본 생성자는 매개변수를 하나도 받지 않는 생성자를 말한다.

```java

public class Car{

    //생성자는 메소드와 비슷하다
    //return type이 없다. 클래스 이름과 같아야 한다.
    //매개변수 0개인 생성자를 기본 생성자라고 한다.
    // 생성자가 하나도 없으면 아무일도 안하는 기본 생성자가 자동으로 만들어진다.
    public Car(){
        System.out.println("자동차가 한대 생성된다.");
    }

    public void run(){
        System.out.println("전륜구동으로 달리다.");
    }

    @Override
    public String toString(){
        return "자동차!";
    }
}

```

여기서

```java
public Car(){
    System.out.println("자동차가 한대 생성된다.");
}
```

에 해당하는 부분이 생성자이다. 이때 Car 생성자에 매계변수가 없으므로 기본 생성자에 해당한다.

만일 이름을 가지고 인스터스가 만들어지게 하고 이를 출력할 수 있도록 하려고 하면,

```java
public Car(String name){
    this.name = name;
}

public void printName(){
    System.out.println("자동차 이름: "+ name);
}
```

을 한 후,

```java
public String name;
```

필드를 생성해 주어야 한다.

다시 정리해 보면,

```java

public class Car{

    //생성자는 메소드와 비슷하다
    //return type이 없다. 클래스 이름과 같아야 한다.
    //매개변수 0개인 생성자를 기본 생성자라고 한다.
    // 생성자가 하나도 없으면 아무일도 안하는 기본 생성자가 자동으로 만들어진다.
    public Car(){
        System.out.println("자동차가 한대 생성된다.");
    }

    public Car(String name){
    this.name = name;
    }

    public void printName(){
    System.out.println("자동차 이름: "+ name);
    }

    public void run(){
        System.out.println("전륜구동으로 달리다.");
    }

    @Override
    public String toString(){
        return "자동차!";
    }
}

```

Car 클래스를 다음과 같이 짤 수 있다. 이를 실행시키기 위해 아래와 같은 코드를 짰다고 하자

```java

public class CarExam02{
    public static void main(String[] args){
        Car c1 = new Car();
        System.out.println(c1);
        c1.printName();
        System.out.println("--------------------");
        Car c2 = new Car("urstory");
        c2.printName();
    }
}

```

위와 같은 코드를 실행하게 됐을 때 나오는 결과 값은 아래와 같다.

```java
// 자동차가 한대 생성됩니다.
//자동차!!
//자동차 이름: null
//----------------------------
//자동차 이름: urstory
```

우선 System.out.println(c1)의 코드에 대한 출력 값은 다음과 같다.

"자동차가 한대 생성됩니다."
"자동차!!"

객체 c1의 생성자가 불러졌을 때 기본 생성자에 의해 "자동차가 한대 생성됩니다"가 출력되고 Car class에 toString이 override 되어 있기 때문에 toString에 해당하는 출력 값도 출력된다.

c1.printName() 같은 경우 name 필드에 아직 아무 값이 안들어 갔으므로 "자동차 이름: null"이 출력된다.

반면 c2.printName() 같은 경우 인스턴스를 생성할 때 name 필드에 해당하는 값 "urstory"가 들어 갔으므로 "자동차 이름: urstory"가 출력된다.

다른 예시를 한번 생각해보자,

User라는 클래스를 만들고 그것을 실행 시킬 수 있는 UserExam이라는 클래스를 만든다.

```java
public class User{
    private String email;
    private String password;
    private String name;

    //생성자를 하나라도 만들게 되면 기본 생성자는 자동으로 안만들어지게 된다.

    public User(String name,  String email){
        this.name = name;
        this.email = email;
    }
}
```

```java
public class UserExam{
    public static void main(String[] args){
        User user = new User();
    }
}
```

위와 같이 코드를 작성 했을 때 UserExam이 User() 생성자를 부를 때 오류가 뜨는 것을 확인할 수 있다. 이는 User 클래스에서 생성자를 만들었으므로 기본 생성자가 생성이 안되게 되고, user 생성자에는 name과 email이 들어가야 하므로 User자리에 name과 email 매개변수를 넣어줘야 한다.

```java
public class UserExam{
    public static void main(String[] args){
        User user = new User("name", "email");
    }
}
```

이런 식으로 적어줘야 한다.

이때 User class에 있는 필드 값을 불러오면 User class에 있는 필드 값들이 private이기 때문에 바로 불러오면 오류가 난다. 이를 위해 getter와 setter 메소드를 사용해야 한다.

```java
public class User{
    private String email;
    private String password;
    private String name;

    public User(String name,  String email){
        this.name = name;
        this.email = email;
    }
    //get 메소드는 필드에 있는 값을 외부로 리턴해주는 메소드이다
    //set 메소드는 필드 값을 변경해주는 메소드이다.
    public String getEmail(){
        return email;
    }

    public String getName(){
        return email;
    }
}
```

이를 실행하기 위해서는 UserExam class에서 getName 메소드를 실행시키면 된다.

```java
public class UserExam{
    public static void main(String[] args){
        User user = new User("name", "email");

        System.out.println(user.getName());
        System.out.printlne(user.getEmail());
    }
}
```

**[this 생성자]**

```java
public class User{
    private String email;
    private String password;
    private String name;

    public User(String name,  String email){
        this(name, email);//this 생성자를 쓸 수도 있다.
    }

    public String getEmail(){
        return email;
    }

    public String getName(){
        return email;
    }
}
```

**[부모의 생성자를 호출 할 때는 super()를 사용한다.]**

- super는 인스턴스 부모를 참조할 때 사용하는 키워드이다.
- super() 생성자는 부모 생성자를 의미한다.
- super() 생성자는 생성자 안에서만 사용가능하다
- super() 생성자는 생성자 안에서 첫번째 줄에만 올 수 있다.
- 생성자는 무조건 super() 생성자를 호출해야 한다.
- 사용자가 super() 생성자를 호출하는 코드를 작성하지 않았다면 자동으로 부모의 기본 생성자가 호출된다
- 부모 클래스가 기본 생성자를 가지고 있지 않다면, 사용자는 반드시 직접 super() 생성자를 호출하는 코드를 작성해야 한다.

Car 클래스를 만들었다.

```java
public class Car2{
    public Car2(){
        System.out.println("Car2() 생성자 호출");
    }
}
```

이러고 난 후, Car2 클래스를 상속받는 Bus2라는 클래스를 만든다.

```java
public class Bus2 extends Car2{

}
```

이러고 난 후 Car2 클래스를 실행하는 코드를 실행하면

```java
public class Car2Exam{
    public static void main(String[] args){
        Car2 c1 = new Car2();

        Bus2 b1 = new Bus2();
    }
}

```

아래에 대한 결과 값은

```java
//Car2() 생성자 호출
//Car2() 생성자 호출
```

이 나온다. 분명 Bus2 클래스에는 아무것도 안 적었는 데 왜 "Car2() 생성자 호출"이 두번 출력된 걸까?

이는 Bus2 클래스에 자동으로 super() 생성자가 출력됐기 때문이다.
